<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Aerial Image Enhancer</title>
    <!-- Tailwind CSS for modern and responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark background */
        }
        .canvas-container {
            position: relative;
            width: 100%;
            min-height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #2e2e4a; /* Darker panel background */
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .canvas-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 10px;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 0.75rem;
            border: 2px solid #5a5a7c;
        }
        .shared-image-item {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            background-color: #3e3e60;
        }
        .shared-image-item:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.5);
        }
        /* Mobile-first adjustments for button layout */
        .button-grid {
            grid-template-columns: repeat(2, 1fr);
        }
        @media (min-width: 768px) {
            .button-grid {
                grid-template-columns: repeat(5, 1fr);
            }
        }
    </style>
</head>
<body class="bg-[#1a1a2e] text-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-[#2e2e4a] rounded-3xl shadow-2xl p-8 w-full max-w-7xl flex flex-col items-center">
        <h1 class="text-4xl font-bold text-gray-100 mb-2">ðŸš€ Pro Aerial Image Enhancer</h1>
        <p class="text-gray-400 text-center mb-4">Upload, enhance, and share high-quality images with the community.</p>
        <p id="userIdDisplay" class="text-xs text-gray-500 mb-6"></p>

        <!-- Image Upload and Display Area -->
        <div class="mb-8 w-full flex flex-col items-center">
            <label for="imageInput" class="mb-6 cursor-pointer bg-gradient-to-r from-purple-600 to-sky-500 text-white font-semibold py-3 px-8 rounded-full shadow-lg hover:from-purple-700 hover:to-sky-600 transition-all duration-300 transform hover:scale-105">
                Upload Image
            </label>
            <input type="file" id="imageInput" accept="image/*" class="hidden"/>
            
            <div class="flex flex-col md:flex-row gap-8 w-full justify-center">
                <!-- Original Image Panel -->
                <div class="canvas-wrapper">
                    <h2 class="text-lg font-semibold text-gray-200 mb-4">Original Image</h2>
                    <div class="canvas-container shadow-md">
                        <canvas id="originalCanvas" class="w-full h-auto"></canvas>
                        <p id="placeholder-original" class="text-gray-500 text-lg absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">Original image</p>
                    </div>
                </div>

                <!-- Enhanced Image Panel -->
                <div class="canvas-wrapper">
                    <h2 class="text-lg font-semibold text-gray-200 mb-4">Enhanced Image</h2>
                    <div class="canvas-container shadow-md">
                        <canvas id="enhancedCanvas" class="w-full h-auto"></canvas>
                        <p id="placeholder-enhanced" class="text-gray-500 text-lg absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">Enhanced image</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls for Filters -->
        <div class="w-full max-w-5xl">
            <h3 class="text-lg font-semibold text-gray-200 mt-4 mb-2">Filters</h3>
            <div class="grid button-grid gap-4">
                <button id="claheFilterBtn" class="bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300">
                    CLAHE
                </button>
                <button id="enhancedSharpeningBtn" class="bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300">
                    Enhanced Sharpen
                </button>
                <button id="medianFilterBtn" class="bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-sky-700 transition duration-300">
                    Median Filter
                </button>
                <button id="adaptiveMedianFilterBtn" class="bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-sky-700 transition duration-300">
                    Adaptive Median
                </button>
                <button id="unsharpMaskingBtn" class="bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-sky-700 transition duration-300">
                    Unsharp Masking
                </button>
                <button id="histogramEqualizationBtn" class="bg-purple-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-purple-700 transition duration-300">
                    Histogram Equalization
                </button>
            </div>
        </div>
        
        <!-- Sliders for Fine-Tuning -->
        <div class="w-full max-w-5xl mt-8">
            <h3 class="text-lg font-semibold text-gray-200 mb-2">Fine-Tuning</h3>
            <div class="flex flex-col gap-4 bg-gray-800 p-4 rounded-lg shadow-inner">
                <!-- Brightness Slider -->
                <div class="flex flex-col">
                    <label for="brightnessSlider" class="text-gray-300 mb-1">Brightness: <span id="brightnessValue">0</span></label>
                    <input type="range" id="brightnessSlider" min="-100" max="100" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg">
                </div>
                <!-- Contrast Slider -->
                <div class="flex flex-col">
                    <label for="contrastSlider" class="text-gray-300 mb-1">Contrast: <span id="contrastValue">0</span></label>
                    <input type="range" id="contrastSlider" min="-100" max="100" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg">
                </div>
                <!-- Gamma Correction Slider -->
                <div class="flex flex-col">
                    <label for="gammaSlider" class="text-gray-300 mb-1">Gamma: <span id="gammaValue">1.0</span></label>
                    <input type="range" id="gammaSlider" min="0.1" max="5.0" value="1.0" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg">
                </div>
                <button id="resetAdjustmentsBtn" class="bg-gray-700 text-gray-200 font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-gray-600 transition duration-300">
                    Reset Adjustments
                </button>
            </div>
        </div>

        <!-- Utility Buttons -->
        <div class="mt-8 flex flex-col md:flex-row gap-4 w-full justify-center">
            <button id="resetBtn" class="bg-gray-700 text-gray-200 font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-gray-600 transition duration-300">
                Reset to Original
            </button>
            <button id="saveOriginalBtn" class="bg-purple-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-purple-700 transition duration-300">
                Save Original
            </button>
            <button id="saveEnhancedBtn" class="bg-green-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-green-600 transition duration-300">
                Save Enhanced
            </button>
            <button id="shareEnhancedBtn" class="bg-indigo-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-600 transition duration-300">
                Share Enhanced Image
            </button>
        </div>
        
        <!-- Status Message Area -->
        <p id="statusMessage" class="text-gray-400 mt-6 h-6 text-center"></p>

        <!-- Shared Images Gallery -->
        <div class="mt-12 w-full">
            <h2 class="text-2xl font-bold text-gray-100 mb-6 text-center">Community Gallery</h2>
            <div id="sharedImagesContainer" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                <!-- Shared images will be loaded here -->
            </div>
        </div>

    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, doc, addDoc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfigString = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Your web app's Firebase configuration
        let firebaseConfig;
        try {
            firebaseConfig = JSON.parse(firebaseConfigString);
        } catch (e) {
            console.error("Failed to parse Firebase config:", e);
            document.getElementById('statusMessage').textContent = 'Error: Firebase configuration invalid. Sharing features disabled.';
            // Set firebaseConfig to an empty object to prevent app from crashing
            firebaseConfig = {};
        }

        // Initialize Firebase variables
        let app = null;
        let db = null;
        let auth = null;
        let userId = null;
        let enhancedImageId = null;

        // --- DOM Elements and State ---
        const imageInput = document.getElementById('imageInput');
        const originalCanvas = document.getElementById('originalCanvas');
        const enhancedCanvas = document.getElementById('enhancedCanvas');
        const ctxOriginal = originalCanvas.getContext('2d');
        const ctxEnhanced = enhancedCanvas.getContext('2d');
        const placeholderOriginal = document.getElementById('placeholder-original');
        const placeholderEnhanced = document.getElementById('placeholder-enhanced');
        const claheFilterBtn = document.getElementById('claheFilterBtn');
        const enhancedSharpeningBtn = document.getElementById('enhancedSharpeningBtn');
        const medianFilterBtn = document.getElementById('medianFilterBtn');
        const adaptiveMedianFilterBtn = document.getElementById('adaptiveMedianFilterBtn');
        const unsharpMaskingBtn = document.getElementById('unsharpMaskingBtn');
        const histogramEqualizationBtn = document.getElementById('histogramEqualizationBtn');
        const resetBtn = document.getElementById('resetBtn');
        const saveOriginalBtn = document.getElementById('saveOriginalBtn');
        const saveEnhancedBtn = document.getElementById('saveEnhancedBtn');
        const shareEnhancedBtn = document.getElementById('shareEnhancedBtn');
        const statusMessage = document.getElementById('statusMessage');
        const sharedImagesContainer = document.getElementById('sharedImagesContainer');

        // New sliders
        const brightnessSlider = document.getElementById('brightnessSlider');
        const contrastSlider = document.getElementById('contrastSlider');
        const gammaSlider = document.getElementById('gammaSlider');
        const brightnessValueDisplay = document.getElementById('brightnessValue');
        const contrastValueDisplay = document.getElementById('contrastValue');
        const gammaValueDisplay = document.getElementById('gammaValue');
        const resetAdjustmentsBtn = document.getElementById('resetAdjustmentsBtn');

        let originalImage = null;
        
        // --- Firebase Init and Setup ---
        try {
            if (firebaseConfig && firebaseConfig.projectId) {
                console.log("Firebase config found. Initializing Firebase...");
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('userIdDisplay').textContent = `User ID: ${userId}`;
                        console.log("Signed in as user:", userId);
                        setupFirestoreListeners();
                    } else {
                        console.log("User is signed out. Attempting to sign in.");
                        await signIn();
                    }
                });
            } else {
                console.error("Firebase is not configured. Public gallery and sharing features will not be available.");
                document.getElementById('statusMessage').textContent = 'Error: Firebase configuration missing. Sharing features disabled.';
                document.getElementById('shareEnhancedBtn').disabled = true;
                document.getElementById('shareEnhancedBtn').classList.add('opacity-50', 'cursor-not-allowed');
            }
        } catch (e) {
            console.error("Failed to parse Firebase config:", e);
            document.getElementById('statusMessage').textContent = 'Error: Firebase configuration invalid. Sharing features disabled.';
            document.getElementById('shareEnhancedBtn').disabled = true;
            document.getElementById('shareEnhancedBtn').classList.add('opacity-50', 'cursor-not-allowed');
        }

        async function signIn() {
            try {
                if (auth) {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                }
            } catch (error) {
                console.error("Firebase Auth error:", error);
            }
        }

        // --- Event Listeners ---
        imageInput.addEventListener('change', handleImageUpload);
        claheFilterBtn.addEventListener('click', () => applyFilter(applyClaheFilter));
        enhancedSharpeningBtn.addEventListener('click', () => applyFilter(applyEnhancedSharpening));
        medianFilterBtn.addEventListener('click', () => applyFilter(applyMedianFilter));
        adaptiveMedianFilterBtn.addEventListener('click', () => applyFilter(applyAdaptiveMedianFilter));
        unsharpMaskingBtn.addEventListener('click', () => applyFilter(applyUnsharpMasking));
        histogramEqualizationBtn.addEventListener('click', () => applyFilter(applyHistogramEqualization));
        resetBtn.addEventListener('click', resetImage);
        saveOriginalBtn.addEventListener('click', () => saveImage(originalCanvas, 'original_image'));
        saveEnhancedBtn.addEventListener('click', () => saveImage(enhancedCanvas, 'enhanced_image'));
        shareEnhancedBtn.addEventListener('click', shareEnhancedImage);

        // Slider listeners
        brightnessSlider.addEventListener('input', applySliderAdjustments);
        contrastSlider.addEventListener('input', applySliderAdjustments);
        gammaSlider.addEventListener('input', applySliderAdjustments);
        resetAdjustmentsBtn.addEventListener('click', resetAdjustments);


        /**
         * Generic filter application wrapper.
         * @param {Function} filterFunction - The image processing function to call.
         */
        function applyFilter(filterFunction) {
            if (!originalImage) {
                statusMessage.textContent = 'Please upload or select an image first.';
                console.warn('Filter application failed: No image loaded.');
                return;
            }
            statusMessage.textContent = `Applying ${filterFunction.name.replace('apply', '')}...`;
            console.log(`Applying filter: ${filterFunction.name}`);
            
            // Re-apply original image before applying new filter
            ctxEnhanced.drawImage(originalImage, 0, 0);

            // Apply filter and any slider adjustments
            filterFunction();
            applySliderAdjustments();
            
            statusMessage.textContent = `Filter applied: ${filterFunction.name.replace('apply', '')}!`;
            console.log('Filter application complete.');
        }

        /**
         * Resets all slider values to their defaults and applies the changes.
         */
        function resetAdjustments() {
            if (!originalImage) return;
            brightnessSlider.value = 0;
            contrastSlider.value = 0;
            gammaSlider.value = 1.0;
            applySliderAdjustments();
            statusMessage.textContent = 'Adjustments reset.';
        }

        /**
         * Applies brightness, contrast, and gamma adjustments based on slider values.
         * This function should be called after any filter to re-apply the adjustments.
         */
        function applySliderAdjustments() {
            if (!originalImage) return;

            const brightness = parseInt(brightnessSlider.value);
            const contrast = parseInt(contrastSlider.value);
            const gamma = parseFloat(gammaSlider.value);

            brightnessValueDisplay.textContent = brightness;
            contrastValueDisplay.textContent = contrast;
            gammaValueDisplay.textContent = gamma.toFixed(1);

            const srcData = ctxOriginal.getImageData(0, 0, enhancedCanvas.width, enhancedCanvas.height);
            const dstData = ctxEnhanced.createImageData(enhancedCanvas.width, enhancedCanvas.height);
            const srcPixels = srcData.data;
            const dstPixels = dstData.data;
            const width = enhancedCanvas.width;
            const height = enhancedCanvas.height;

            const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));

            for (let i = 0; i < srcPixels.length; i += 4) {
                let r = srcPixels[i];
                let g = srcPixels[i + 1];
                let b = srcPixels[i + 2];

                // Brightness
                r += brightness;
                g += brightness;
                b += brightness;

                // Contrast
                r = contrastFactor * (r - 128) + 128;
                g = contrastFactor * (g - 128) + 128;
                b = contrastFactor * (b - 128) + 128;
                
                // Gamma Correction
                r = 255 * Math.pow(r / 255, 1 / gamma);
                g = 255 * Math.pow(g / 255, 1 / gamma);
                b = 255 * Math.pow(b / 255, 1 / gamma);

                dstPixels[i] = Math.max(0, Math.min(255, r));
                dstPixels[i + 1] = Math.max(0, Math.min(255, g));
                dstPixels[i + 2] = Math.max(0, Math.min(255, b));
                dstPixels[i + 3] = srcPixels[i + 3]; // Preserve alpha
            }

            ctxEnhanced.putImageData(dstData, 0, 0);
        }

        // --- Firestore Functions ---
        function setupFirestoreListeners() {
            if (!db) return;
            const publicImagesRef = collection(db, `/artifacts/${appId}/public/data/public_images`);
            onSnapshot(publicImagesRef, (snapshot) => {
                console.log('Fetching shared images from Firestore...');
                sharedImagesContainer.innerHTML = '';
                snapshot.forEach((doc) => {
                    const imageData = doc.data();
                    createSharedImageElement(doc.id, imageData.base64);
                });
                console.log('Shared images loaded successfully.');
            }, (error) => {
                console.error("Error fetching shared images:", error);
            });
        }

        function createSharedImageElement(id, base64Data) {
            const img = new Image();
            img.src = base64Data;
            img.classList.add('w-full', 'h-auto', 'rounded-lg', 'shadow-md', 'shared-image-item');
            img.addEventListener('click', () => {
                loadSharedImage(base64Data);
                enhancedImageId = id;
            });
            sharedImagesContainer.appendChild(img);
        }

        function loadSharedImage(base64Data) {
            const img = new Image();
            img.onload = () => {
                console.log('Shared image loaded into memory.');
                originalImage = img;
                // Draw the loaded image directly to both canvases
                originalCanvas.width = originalImage.width;
                originalCanvas.height = originalImage.height;
                enhancedCanvas.width = originalImage.width;
                enhancedCanvas.height = originalImage.height;

                ctxOriginal.drawImage(originalImage, 0, 0);
                ctxEnhanced.drawImage(originalImage, 0, 0);

                // Reset sliders to default values after loading a new image
                resetAdjustments();

                statusMessage.textContent = 'Shared image loaded!';
                placeholderOriginal.style.display = 'none';
                placeholderEnhanced.style.display = 'none';
                console.log('Shared image drawn to canvases.');
            };
            img.onerror = () => {
                console.error('Failed to load shared image.');
                statusMessage.textContent = 'Failed to load shared image.';
            };
            img.src = base64Data;
        }

        async function shareEnhancedImage() {
            if (!originalImage) {
                statusMessage.textContent = 'Please upload or select an image to share.';
                console.warn('Share failed: No image to share.');
                return;
            }
            if (!db || !userId) {
                statusMessage.textContent = 'Sharing is disabled due to a Firebase configuration error.';
                console.warn('Share failed: Firebase not initialized.');
                return;
            }

            statusMessage.textContent = 'Sharing image...';
            console.log('Attempting to share enhanced image...');
            const base64Data = enhancedCanvas.toDataURL('image/jpeg', 0.8);
            const imageDoc = {
                base64: base64Data,
                sharedBy: userId,
                timestamp: new Date()
            };

            const publicImagesRef = collection(db, `/artifacts/${appId}/public/data/public_images`);
            try {
                if (enhancedImageId) {
                     await updateDoc(doc(db, `/artifacts/${appId}/public/data/public_images`, enhancedImageId), imageDoc);
                    statusMessage.textContent = 'Shared image updated successfully!';
                    console.log('Image updated in Firestore.');
                } else {
                    await addDoc(publicImagesRef, imageDoc);
                    statusMessage.textContent = 'Enhanced image shared successfully!';
                    console.log('New image added to Firestore.');
                }
            } catch (e) {
                console.error("Error sharing image:", e);
                statusMessage.textContent = 'Error sharing image. Check the console for details.';
            }
        }

        // --- Image Handling and Drawing ---
        function handleImageUpload(event) {
            console.log('1. File selection event triggered.');
            const file = event.target.files[0];
            
            if (!file) {
                statusMessage.textContent = 'No file selected.';
                console.warn('2. No file selected.');
                return;
            }

            statusMessage.textContent = 'Reading file...';
            console.log(`3. File selected: ${file.name}, Type: ${file.type}, Size: ${file.size} bytes.`);

            const reader = new FileReader();

            reader.onload = (e) => {
                console.log('4. FileReader onload triggered. File read successfully.');
                statusMessage.textContent = 'Loading image into memory...';
                
                const img = new Image();
                img.onload = () => {
                    console.log('5. Image onload triggered. Image is fully loaded.');
                    console.log(`6. Image dimensions: ${img.width}x${img.height}`);

                    if (img.width > 0 && img.height > 0) {
                        originalImage = img;
                        displayImageOnCanvases();
                        resetAdjustments();
                        
                        placeholderOriginal.style.display = 'none';
                        placeholderEnhanced.style.display = 'none';
                        statusMessage.textContent = 'Image loaded successfully!';
                        console.log('7. Image successfully drawn to canvases.');
                    } else {
                        statusMessage.textContent = 'Error: Loaded image has invalid dimensions.';
                        console.error('7. Image loaded but has invalid dimensions.');
                    }
                };
                img.onerror = () => {
                    statusMessage.textContent = 'Error: Image file could not be loaded.';
                    console.error('5. Image failed to load. Check the file source or format.');
                };
                img.src = e.target.result;
            };

            reader.onerror = (e) => {
                statusMessage.textContent = 'Error: Failed to read the file.';
                console.error('4. FileReader failed to read the file:', e.target.error);
            };

            reader.readAsDataURL(file);
        }

        function displayImageOnCanvases() {
            if (!originalImage) return;

            originalCanvas.width = originalImage.width;
            originalCanvas.height = originalImage.height;
            enhancedCanvas.width = originalImage.width;
            enhancedCanvas.height = originalImage.height;
    
            ctxOriginal.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            ctxEnhanced.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            ctxOriginal.drawImage(originalImage, 0, 0);
            ctxEnhanced.drawImage(originalImage, 0, 0);
        }

        function resetImage() {
            if (originalImage) {
                ctxEnhanced.drawImage(originalImage, 0, 0);
                resetAdjustments();
                statusMessage.textContent = 'Enhanced image reset to original.';
            } else {
                statusMessage.textContent = 'Please upload an image first.';
            }
        }

        function saveImage(canvas, filename) {
            const link = document.createElement('a');
            link.download = `${filename}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            statusMessage.textContent = `Image saved as ${link.download}.`;
        }

        // --- Image Processing Filters ---
        
        /**
         * Applies the new CLAHE filter for local contrast enhancement.
         * @param {number} clipLimit - The clip limit for the histogram.
         * @param {number} tileSize - The size of the tile for local processing.
         */
        function applyClaheFilter(clipLimit = 2, tileSize = 8) {
            const srcData = ctxEnhanced.getImageData(0, 0, enhancedCanvas.width, enhancedCanvas.height);
            const dstData = ctxEnhanced.createImageData(srcData);
            const srcPixels = srcData.data;
            const dstPixels = dstData.data;
            const width = enhancedCanvas.width;
            const height = enhancedCanvas.height;

            // Process each channel separately
            for (let channel = 0; channel < 3; channel++) {
                // CLAHE involves dividing the image into tiles
                const tileWidth = Math.floor(width / tileSize);
                const tileHeight = Math.floor(height / tileSize);
                const tileHistograms = new Array(tileSize * tileSize).fill(0).map(() => new Array(256).fill(0));

                // Step 1: Compute histograms for each tile
                for (let ty = 0; ty < tileSize; ty++) {
                    for (let tx = 0; tx < tileSize; tx++) {
                        const tileIndex = ty * tileSize + tx;
                        for (let y = ty * tileHeight; y < (ty + 1) * tileHeight; y++) {
                            for (let x = tx * tileWidth; x < (tx + 1) * tileWidth; x++) {
                                if (x < width && y < height) {
                                    const index = (y * width + x) * 4 + channel;
                                    tileHistograms[tileIndex][srcPixels[index]]++;
                                }
                            }
                        }
                    }
                }

                // Step 2: Clip and redistribute histograms
                const newCdfs = tileHistograms.map(histogram => {
                    // Clip the histogram
                    let excess = 0;
                    for (let i = 0; i < 256; i++) {
                        if (histogram[i] > clipLimit) {
                            excess += histogram[i] - clipLimit;
                            histogram[i] = clipLimit;
                        }
                    }
                    const redistributionAmount = Math.floor(excess / 256);
                    for (let i = 0; i < 256; i++) {
                        histogram[i] += redistributionAmount;
                    }

                    // Compute CDF (Cumulative Distribution Function)
                    const cdf = new Array(256).fill(0);
                    let sum = 0;
                    for (let i = 0; i < 256; i++) {
                        sum += histogram[i];
                        cdf[i] = sum;
                    }
                    const minCdf = cdf[0];
                    return cdf.map(val => Math.floor(255 * (val - minCdf) / (sum - minCdf)));
                });

                // Step 3: Interpolate and apply new pixel values
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4 + channel;

                        // Bilinear interpolation for smooth transitions between tiles
                        const tx = x / tileWidth - 0.5;
                        const ty = y / tileHeight - 0.5;
                        const tx1 = Math.floor(tx);
                        const ty1 = Math.floor(ty);
                        const dx = tx - tx1;
                        const dy = ty - ty1;

                        const val = srcPixels[index];

                        const cdfA = (tx1 >= 0 && ty1 >= 0) ? newCdfs[ty1 * tileSize + tx1][val] : 0;
                        const cdfB = (tx1 + 1 < tileSize && ty1 >= 0) ? newCdfs[ty1 * tileSize + tx1 + 1][val] : 0;
                        const cdfC = (tx1 >= 0 && ty1 + 1 < tileSize) ? newCdfs[(ty1 + 1) * tileSize + tx1][val] : 0;
                        const cdfD = (tx1 + 1 < tileSize && ty1 + 1 < tileSize) ? newCdfs[(ty1 + 1) * tileSize + tx1 + 1][val] : 0;

                        const interpolatedValue = (1 - dx) * ((1 - dy) * cdfA + dy * cdfC) + dx * ((1 - dy) * cdfB + dy * cdfD);
                        dstPixels[index] = Math.round(interpolatedValue);
                    }
                }
            }

            ctxEnhanced.putImageData(dstData, 0, 0);
        }

        /**
         * Applies an enhanced sharpening filter using a more aggressive kernel.
         */
        function applyEnhancedSharpening() {
            const srcData = ctxEnhanced.getImageData(0, 0, enhancedCanvas.width, enhancedCanvas.height);
            const dstData = ctxEnhanced.createImageData(enhancedCanvas.width, enhancedCanvas.height);
            const srcPixels = srcData.data;
            const dstPixels = dstData.data;
            const width = enhancedCanvas.width;
            const height = enhancedCanvas.height;

            const kernel = [
                -1, -1, -1,
                -1, 9, -1,
                -1, -1, -1
            ];
            const kernelSize = 3;
            const halfKernel = Math.floor(kernelSize / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0;
                    
                    for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                        for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                            const neighborX = x + kx;
                            const neighborY = y + ky;
                            const kernelValue = kernel[(ky + halfKernel) * kernelSize + (kx + halfKernel)];

                            if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height) {
                                const index = (neighborY * width + neighborX) * 4;
                                r += srcPixels[index] * kernelValue;
                                g += srcPixels[index + 1] * kernelValue;
                                b += srcPixels[index + 2] * kernelValue;
                            }
                        }
                    }
                    const destIndex = (y * width + x) * 4;
                    dstPixels[destIndex] = Math.max(0, Math.min(255, r));
                    dstPixels[destIndex + 1] = Math.max(0, Math.min(255, g));
                    dstPixels[destIndex + 2] = Math.max(0, Math.min(255, b));
                    dstPixels[destIndex + 3] = srcPixels[destIndex + 3];
                }
            }

            ctxEnhanced.putImageData(dstData, 0, 0);
        }

        /**
         * Applies a Median Filter to the enhanced image on the canvas.
         */
        function applyMedianFilter() {
            const srcData = ctxEnhanced.getImageData(0, 0, enhancedCanvas.width, enhancedCanvas.height);
            const dstData = ctxEnhanced.createImageData(enhancedCanvas.width, enhancedCanvas.height);
            const srcPixels = srcData.data;
            const dstPixels = dstData.data;
            const width = enhancedCanvas.width;
            const height = enhancedCanvas.height;

            const kernelSize = 3;
            const halfKernel = Math.floor(kernelSize / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const pixelsR = [];
                    const pixelsG = [];
                    const pixelsB = [];

                    for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                        for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                            const neighborX = x + kx;
                            const neighborY = y + ky;

                            if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height) {
                                const index = (neighborY * width + neighborX) * 4;
                                pixelsR.push(srcPixels[index]);
                                pixelsG.push(srcPixels[index + 1]);
                                pixelsB.push(srcPixels[index + 2]);
                            }
                        }
                    }

                    pixelsR.sort((a, b) => a - b);
                    pixelsG.sort((a, b) => a - b);
                    pixelsB.sort((a, b) => a - b);

                    const medianIndex = Math.floor(pixelsR.length / 2);
                    const destIndex = (y * width + x) * 4;

                    dstPixels[destIndex] = pixelsR[medianIndex];
                    dstPixels[destIndex + 1] = pixelsG[medianIndex];
                    dstPixels[destIndex + 2] = pixelsB[medianIndex];
                    dstPixels[destIndex + 3] = srcPixels[destIndex + 3];
                }
            }
            ctxEnhanced.putImageData(dstData, 0, 0);
        }

        /**
         * Applies an Adaptive Median Filter to the enhanced image.
         */
        function applyAdaptiveMedianFilter() {
            const srcData = ctxEnhanced.getImageData(0, 0, enhancedCanvas.width, enhancedCanvas.height);
            const dstData = ctxEnhanced.createImageData(enhancedCanvas.width, enhancedCanvas.height);
            const srcPixels = srcData.data;
            const dstPixels = dstData.data;
            const width = enhancedCanvas.width;
            const height = enhancedCanvas.height;

            const minKernelSize = 3;
            const maxKernelSize = 7;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const destIndex = (y * width + x) * 4;
                    let currentKernelSize = minKernelSize;
                    let processed = false;

                    while (currentKernelSize <= maxKernelSize && !processed) {
                        const halfKernel = Math.floor(currentKernelSize / 2);
                        const pixelsR = [];
                        const pixelsG = [];
                        const pixelsB = [];

                        for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                            for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                                const neighborX = x + kx;
                                const neighborY = y + ky;

                                if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height) {
                                    const index = (neighborY * width + neighborX) * 4;
                                    pixelsR.push(srcPixels[index]);
                                    pixelsG.push(srcPixels[index + 1]);
                                    pixelsB.push(srcPixels[index + 2]);
                                }
                            }
                        }

                        pixelsR.sort((a, b) => a - b);
                        pixelsG.sort((a, b) => a - b);
                        pixelsB.sort((a, b) => a - b);
                        const medianIndex = Math.floor(pixelsR.length / 2);

                        const minR = pixelsR[0], maxR = pixelsR[pixelsR.length - 1], medianR = pixelsR[medianIndex];
                        const minG = pixelsG[0], maxG = pixelsG[pixelsG.length - 1], medianG = pixelsG[medianIndex];
                        const minB = pixelsB[0], maxB = pixelsB[pixelsB.length - 1], medianB = pixelsB[medianIndex];
                        
                        const pixelR = srcPixels[destIndex];
                        const pixelG = srcPixels[destIndex + 1];
                        const pixelB = srcPixels[destIndex + 2];

                        if (medianR > minR && medianR < maxR && medianG > minG && medianG < maxG && medianB > minB && medianB < maxB) {
                            if (pixelR > minR && pixelR < maxR && pixelG > minG && pixelG < maxG && pixelB > minB && pixelB < maxB) {
                                dstPixels[destIndex] = pixelR;
                                dstPixels[destIndex + 1] = pixelG;
                                dstPixels[destIndex + 2] = pixelB;
                            } else {
                                dstPixels[destIndex] = medianR;
                                dstPixels[destIndex + 1] = medianG;
                                dstPixels[destIndex + 2] = medianB;
                            }
                            processed = true;
                        } else {
                            currentKernelSize += 2;
                        }
                    }

                    if (!processed) {
                        const pixelsR = [];
                        const pixelsG = [];
                        const pixelsB = [];
                        const halfKernel = Math.floor(maxKernelSize / 2);

                        for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                            for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                                const neighborX = x + kx;
                                const neighborY = y + ky;
                                if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height) {
                                    const index = (neighborY * width + neighborX) * 4;
                                    pixelsR.push(srcPixels[index]);
                                    pixelsG.push(srcPixels[index + 1]);
                                    pixelsB.push(srcPixels[index + 2]);
                                }
                            }
                        }
                        pixelsR.sort((a, b) => a - b);
                        pixelsG.sort((a, b) => a - b);
                        pixelsB.sort((a, b) => a - b);
                        const medianIndex = Math.floor(pixelsR.length / 2);

                        dstPixels[destIndex] = pixelsR[medianIndex];
                        dstPixels[destIndex + 1] = pixelsG[medianIndex];
                        dstPixels[destIndex + 2] = pixelsB[medianIndex];
                    }

                    dstPixels[destIndex + 3] = srcPixels[destIndex + 3];
                }
            }
            ctxEnhanced.putImageData(dstData, 0, 0);
        }

        /**
         * Applies the Unsharp Masking technique.
         */
        function applyUnsharpMasking() {
            const srcData = ctxEnhanced.getImageData(0, 0, enhancedCanvas.width, enhancedCanvas.height);
            const dstData = ctxEnhanced.createImageData(enhancedCanvas.width, enhancedCanvas.height);
            const srcPixels = srcData.data;
            const dstPixels = dstData.data;
            const width = enhancedCanvas.width;
            const height = enhancedCanvas.height;

            const blurredData = applyGaussianBlur(srcData);
            const blurredPixels = blurredData.data;

            const amount = 1.5; 

            for (let i = 0; i < srcPixels.length; i += 4) {
                const rDetail = srcPixels[i] - blurredPixels[i];
                const gDetail = srcPixels[i + 1] - blurredPixels[i + 1];
                const bDetail = srcPixels[i + 2] - blurredPixels[i + 2];
                
                const r = srcPixels[i] + rDetail * amount;
                const g = srcPixels[i + 1] + gDetail * amount;
                const b = srcPixels[i + 2] + bDetail * amount;

                dstPixels[i] = Math.max(0, Math.min(255, r));
                dstPixels[i + 1] = Math.max(0, Math.min(255, g));
                dstPixels[i + 2] = Math.max(0, Math.min(255, b));
                dstPixels[i + 3] = srcPixels[i + 3];
            }

            ctxEnhanced.putImageData(dstData, 0, 0);
        }
        
        /**
         * Helper function for Unsharp Masking: Applies a Gaussian Blur filter.
         */
        function applyGaussianBlur(imageData) {
            const srcData = imageData;
            const dstData = ctxEnhanced.createImageData(srcData);
            const srcPixels = srcData.data;
            const dstPixels = dstData.data;
            const width = enhancedCanvas.width;
            const height = enhancedCanvas.height;

            const kernelSize = 5;
            const halfKernel = Math.floor(kernelSize / 2);
            const sigma = 1.0;
            const kernel = createGaussianKernel(kernelSize, sigma);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0;
                    
                    for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                        for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                            const neighborX = x + kx;
                            const neighborY = y + ky;
                            const kernelValue = kernel[(ky + halfKernel) * kernelSize + (kx + halfKernel)];

                            if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height) {
                                const index = (neighborY * width + neighborX) * 4;
                                r += srcPixels[index] * kernelValue;
                                g += srcPixels[index + 1] * kernelValue;
                                b += srcPixels[index + 2] * kernelValue;
                            }
                        }
                    }

                    const destIndex = (y * width + x) * 4;
                    dstPixels[destIndex] = r;
                    dstPixels[destIndex + 1] = g;
                    dstPixels[destIndex + 2] = b;
                    dstPixels[destIndex + 3] = srcPixels[destIndex + 3];
                }
            }
            return dstData;
        }

        /**
         * Helper function to create a Gaussian kernel.
         */
        function createGaussianKernel(size, sigma) {
            const kernel = new Array(size * size);
            const halfSize = Math.floor(size / 2);
            let sum = 0;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const dx = x - halfSize;
                    const dy = y - halfSize;
                    const value = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
                    kernel[y * size + x] = value;
                    sum += value;
                }
            }
            
            for (let i = 0; i < kernel.length; i++) {
                kernel[i] /= sum;
            }

            return kernel;
        }

        /**
         * Applies Histogram Equalization to the enhanced image.
         */
        function applyHistogramEqualization() {
            const srcData = ctxEnhanced.getImageData(0, 0, enhancedCanvas.width, enhancedCanvas.height);
            const dstData = ctxEnhanced.createImageData(enhancedCanvas.width, enhancedCanvas.height);
            const srcPixels = srcData.data;
            const dstPixels = dstData.data;
            const numPixels = srcPixels.length / 4;

            // Step 1: Compute histogram for each color channel
            const histogram = [[], [], []];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 256; j++) {
                    histogram[i][j] = 0;
                }
            }
            for (let i = 0; i < srcPixels.length; i += 4) {
                histogram[0][srcPixels[i]]++;
                histogram[1][srcPixels[i+1]]++;
                histogram[2][srcPixels[i+2]]++;
            }

            // Step 2: Compute CDF (Cumulative Distribution Function)
            const cdf = [[], [], []];
            for (let i = 0; i < 3; i++) {
                let sum = 0;
                for (let j = 0; j < 256; j++) {
                    sum += histogram[i][j];
                    cdf[i][j] = sum;
                }
            }

            // Step 3: Normalize CDF to map to new pixel values
            const newValues = [[], [], []];
            for (let i = 0; i < 3; i++) {
                const minCdf = cdf[i][0];
                for (let j = 0; j < 256; j++) {
                    newValues[i][j] = Math.round((cdf[i][j] - minCdf) / (numPixels - minCdf) * 255);
                }
            }

            // Step 4: Apply new pixel values
            for (let i = 0; i < srcPixels.length; i += 4) {
                dstPixels[i] = newValues[0][srcPixels[i]];
                dstPixels[i+1] = newValues[1][srcPixels[i+1]];
                dstPixels[i+2] = newValues[2][srcPixels[i+2]];
                dstPixels[i+3] = srcPixels[i+3];
            }
            
            ctxEnhanced.putImageData(dstData, 0, 0);
        }
    </script>
</body>
</html>
